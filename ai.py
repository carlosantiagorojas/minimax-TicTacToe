"""Computer (AI) of the TicTacToe"""
from position import Position
from typing import Tuple
import time

class AI:
    """Computer (AI) of the TicTacToe
    
    Attributes:
    ----------
    position : Position
        The current position of the game.
        
    Methods:
    -------
    make_ai_move() -> bool
        Make a move in the TicTacToe based on the minimax algorithm result.
    minimax(position: Position, depth: int, maximizingPlayer: bool) -> Tuple[float, Position]   
        Minimax algorithm.
    """

    def __init__(self, position: Position) -> None:
        """Initialize the AI with the current position in the game.

        Args:
            position (Position): The position
        """
        self.position = position

    def make_ai_move(self) -> bool:
        """Make a move in the TicTacToe based on the minimax algorithm result."""
        start_time = time.time()
        
        # Choose the best move
        best_move_value, best_move = self.minimax(self.position, self.position.get_empty_positions(), True)
        print("\nMinimax result: ", best_move_value)    
        # self.position.print_pos_children()
        
        # If there is no valid move
        if best_move is None:
            print("ERROR: No valid move found")
            return False
        
        # Generate a copy of the position to avoid changing the original position 
        # because we want to avoid that the children are generated by reference
        self.position = best_move.copy()
        
        end_time = time.time()  # Stop the timer
        execution_time = end_time - start_time  # Calculate the execution time
        print(f"The minimax method executed in {execution_time} seconds")
        
        print("\nComputer move:")
        return True
    
    def minimax(self, position: Position, depth: int, maximizingPlayer: bool) -> Tuple[float, Position]:
        """Minimax algorithm.

        Args:
            position (Position): The current position.
            depth (int): The depth of the tree.
            maximizingPlayer (bool): True if the Player is maximizing, False otherwise.

        Returns:
            Tuple[float, Position]: The evaluation of the position and the position itself.
        """
        # print("Depth: ", depth)
        if depth == 0 or position.game_over:
            return position.evaluation, position
        
        if maximizingPlayer:
            # print("""
            #     -----------------
            #       maximizingPlayer
            #     -----------------
            #       """)
            maxEvaluation = float('-inf') 
            maxChild = None
            for move in position.get_possible_moves():
                # child.print_tic_tac_toe()
                child = position.copy()
                child.pos_list[move] = 0
                eval, _ = self.minimax(child, depth - 1, False)
                # print("Self evaluation: ", eval)
                if eval > maxEvaluation:
                    maxEvaluation = eval
                    maxChild = child
                    # print("Max evaluation: ", maxEvaluation)
            return maxEvaluation, maxChild
        else:
            # print("""
            #     -----------------
            #       minimizinglayer
            #     -----------------
            #       """)
            minEvaluation = float('inf')
            minChild = None
            for move in position.get_possible_moves():
                # child.print_tic_tac_toe()                
                child = position.copy()
                child.pos_list[move] = 1  # Make the move for the player
                eval, _ = self.minimax(child, depth - 1, True)
                # print("Self evaluation: ", child.evaluation)
                if eval < minEvaluation:
                    minEvaluation = eval
                    minChild = child
                    # print("Min evaluation: ", minEvaluation)
            return minEvaluation, minChild