"""Computer (AI) of the TicTacToe"""
from position import Position
from typing import Tuple


class AI:
    """Computer (AI) of the TicTacToe
    
    Attributes:
    ----------
    position : Position
        The current position of the game.
        
    Methods:
    -------
    make_ai_move() -> bool
        Make a move in the TicTacToe based on the minimax algorithm result.
    minimax(position: Position, depth: int, maximizingPlayer: bool, 
            alpha: float, beta: float) -> Tuple[float, Position]
        Minimax algorithm.
    """

    def __init__(self, position: Position) -> None:
        """Initialize the AI with the current position in the game.

        Args:
            position (Position): The position
        """
        self.position = position

    def make_ai_move(self) -> bool:
        """Make a move in the TicTacToe based on the minimax algorithm result."""
        
        # Choose the best move
        best_move_value, best_move = self.minimax(self.position, self.position.get_empty_positions(), True)
        
        # If there is no valid move
        if best_move is None:
            print("ERROR: No valid move found")
            return False
        
        # Generate a copy of the position to avoid changing the original position 
        # because we want to avoid that the children are generated by reference
        self.position = best_move.copy()
        
        print("\nComputer move:")
        return True
    
    def minimax(self, position: Position, depth: int, maximizingPlayer: bool,
                alpha: float = float('-inf'), beta: float = float('inf')) -> Tuple[float, Position]:
        """Minimax algorithm.

        Args:
            position (Position): The current position.
            depth (int): The depth of the tree.
            maximizingPlayer (bool): True if the Player is maximizing, False otherwise.
            alpha (float): The best value that the maximizing player is assured of.
            beta (float): The best value that the minimizing player is assured of.
        Returns:
            Tuple[float, Position]: The evaluation of the position and the position itself.
        """
        if depth == 0 or position.game_over:
            return position.evaluation, position
        
        if maximizingPlayer:
            maxEvaluation = float('-inf') 
            maxChild = None
            for move in position.get_possible_moves():
                child = position.copy()
                child.pos_list[move] = 0
                eval, _ = self.minimax(child, depth - 1, False, alpha, beta)
                if eval > maxEvaluation:
                    maxEvaluation = eval
                    maxChild = child
                alpha = max(alpha, eval)
                if beta <= alpha:
                    break
            return maxEvaluation, maxChild
        else:
            minEvaluation = float('inf')
            minChild = None
            for move in position.get_possible_moves():          
                child = position.copy()
                eval, _ = self.minimax(child, depth - 1, True, alpha, beta)
                if eval < minEvaluation:
                    minEvaluation = eval
                    minChild = child
                beta = min(beta, eval)
                if beta <= alpha:
                    break
            return minEvaluation, minChild