"""Computer (AI) of the TicTacToe"""
from position import Position
from typing import Union

class AI:

    def __init__(self, position: Position) -> None:
        """Initialize the AI with the current position in the game.

        Args:
            position (Position): The position
        """
        self.position = position

    def make_ai_move(self) -> bool:
        """Make a move in the TicTacToe based on the minimax algorithm result."""
        # Create the first children for the first move to be able to do the minimax
        self.position.create_children(self.position.get_possible_moves().copy(), True)

        # Choose the best move
        best_move_value = self.minimax(self.position, 2, True)
        print("\nMinimax result: ", best_move_value)    
        
        # Search the child that have the position of the best move, then
        # generate a copy of the position to avoid changing the original position 
        # because we want to avoid that the children are generated by reference
        self.position = self.position.search_best_move(best_move_value).copy()
        print("\nComputer move:")

    def minimax(self, position: Position, depth: int, maximizingPlayer: bool) -> float:
        """Minimax algorithm.

        Args:
            position (Position): The current position.
            depth (int): The depth of the tree.
            maximizingPlayer (bool): True if the Player is maximizing, False otherwise.

        Returns:
            float: The evaluation of the position.
        """
        print("depth: ", depth)
        if depth == 0 or position.game_over:
            return position.evaluation
        
        if maximizingPlayer:
            print("""
                -----------------
                  maximizingPlayer
                -----------------
                  """)
            maxEvaluation = float('-inf')
            for child in position.children:
                child.print_tic_tac_toe()
                child.create_children(child.get_possible_moves().copy(), False)
                eval = self.minimax(child, depth - 1, False)
                print("eval: ", eval)
                maxEvaluation = max(maxEvaluation, eval)
            return maxEvaluation
        else:
            print("""
                -----------------
                  minimizinglayer
                -----------------
                  """)
            minEvaluation = float('inf')
            for child in position.children:
                child.print_tic_tac_toe()
                child.create_children(child.get_possible_moves().copy(), True)
                eval = self.minimax(child, depth - 1, True)
                minEvaluation = min(minEvaluation, eval)
            return minEvaluation