"""Computer (AI) of the TicTacToe"""
from position import Position
from typing import Tuple

class AI:

    def __init__(self, position: Position) -> None:
        """Initialize the AI with the current position in the game.

        Args:
            position (Position): The position
        """
        self.position = position

    def make_ai_move(self) -> bool:
        """Make a move in the TicTacToe based on the minimax algorithm result."""

        # Choose the best move
        best_move_value, best_move = self.minimax(self.position, self.position.get_empty_positions(), True)
        print("\nMinimax result: ", best_move_value)    
        # self.position.print_pos_children()
        
        if best_move is None:
            print("ERROR: No valid move found")
            return False
        
        # Generate a copy of the position to avoid changing the original position 
        # because we want to avoid that the children are generated by reference
        self.position = best_move.copy()
        print("\nComputer move:")
        return True
    
    def minimax(self, position: Position, depth: int, maximizingPlayer: bool) -> Tuple[float, Position]:
        """Minimax algorithm.

        Args:
            position (Position): The current position.
            depth (int): The depth of the tree.
            maximizingPlayer (bool): True if the Player is maximizing, False otherwise.

        Returns:
            Tuple[float, Position]: The evaluation of the position and the position itself.
        """
        # print("Depth: ", depth)
        if depth == 0 or position.game_over:
            return position.evaluation, position
        
        if maximizingPlayer:
            # print("""
            #     -----------------
            #       maximizingPlayer
            #     -----------------
            #       """)
            maxEvaluation = float('-inf') 
            maxChild = None
            for move in position.get_possible_moves():
                # child.print_tic_tac_toe()
                child = position.copy()
                child.pos_list[move] = 0
                eval, _ = self.minimax(child, depth - 1, False)
                # print("Self evaluation: ", eval)
                if eval > maxEvaluation:
                    maxEvaluation = eval
                    maxChild = child
                    # print("Max evaluation: ", maxEvaluation)
            return maxEvaluation, maxChild
        else:
            # print("""
            #     -----------------
            #       minimizinglayer
            #     -----------------
            #       """)
            minEvaluation = float('inf')
            minChild = None
            for move in position.get_possible_moves():
                # child.print_tic_tac_toe()                
                child = position.copy()
                child.pos_list[move] = 1  # Make the move for the player
                eval, _ = self.minimax(child, depth - 1, True)
                # print("Self evaluation: ", child.evaluation)
                if eval < minEvaluation:
                    minEvaluation = eval
                    minChild = child
                    # print("Min evaluation: ", minEvaluation)
            return minEvaluation, minChild