"""Computer (AI) of the TicTacToe"""
from position import Position
from typing import Tuple

class AI:

    def __init__(self, position: Position) -> None:
        """Initialize the AI with the current position in the game.

        Args:
            position (Position): The position
        """
        self.position = position

    def make_ai_move(self) -> bool:
        """Make a move in the TicTacToe based on the minimax algorithm result."""
        # Create the first children for the first move to be able to do the minimax
        self.position.create_children(
            self.position.get_possible_moves().copy(), True)

        # Choose the best move
        best_move_value, best_move = self.minimax(self.position, 2, True)
        print("\nMinimax result: ", best_move_value)    
        self.position.print_pos_children()
        
        if best_move is None:
            print("ERROR: No valid move found")
            return False
        
        # Generate a copy of the position to avoid changing the original position 
        # because we want to avoid that the children are generated by reference
        self.position = best_move.copy()
        print("\nComputer move:")
        return True
    
    def minimax(self, position: Position, depth: int, maximizingPlayer: bool) -> Tuple[float, Position]:
        """Minimax algorithm.

        Args:
            position (Position): The current position.
            depth (int): The depth of the tree.
            maximizingPlayer (bool): True if the Player is maximizing, False otherwise.

        Returns:
            Tuple[float, Position]: The evaluation of the position and the position itself.
        """
        print("Depth: ", depth)
        if depth == 0 or position.game_over:
            return position.evaluation, position
        
        if maximizingPlayer:
            print("""
                -----------------
                  maximizingPlayer
                -----------------
                  """)
            maxEvaluation = float('-inf')
            maxChild = None
            for child in position.children:
                child.print_tic_tac_toe()
                child.create_children(child.get_possible_moves().copy(), False)
                eval, _ = self.minimax(child, depth - 1, False)
                print("Self evaluation: ", eval)
                if eval > maxEvaluation:
                    maxEvaluation = eval
                    maxChild = child
                    print("Max evaluation: ", maxEvaluation)
            return maxEvaluation, maxChild
        else:
            print("""
                -----------------
                  minimizinglayer
                -----------------
                  """)
            minEvaluation = float('inf')
            minChild = None
            for child in position.children:
                child.print_tic_tac_toe()                
                child.create_children(child.get_possible_moves().copy(), True)
                eval, _ = self.minimax(child, depth - 1, True)
                print("self evaluation: ", child.evaluation)
                if eval < minEvaluation:
                    minEvaluation = eval
                    minChild = child
                    print("Min evaluation: ", minEvaluation)
            return minEvaluation, minChild